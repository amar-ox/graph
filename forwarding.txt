=================== show topology =======================
MATCH (r:Router)-[:HAS_PORT]->(p:Port)-[:LINKS_TO]->(pp:Port)<-[:HAS_PORT]-(rr:Router)
CALL apoc.create.vRelationship(r,'LINK',{},rr) YIELD rel
RETURN r,rel,rr

=================== clean process =======================
MATCH (s:State) DETACH DELETE s

===================== print trees =======================
MATCH (r:Router)-[:HAS_PORT]->(p:Port)-[:LINKS_TO]-()
WITH DISTINCT r,p
WITH collect(r.name+','+p.name) as ports
CALL trees.print(ports, true) YIELD port, tree, flag
//WITH port, tree, flag WHERE flag = 'dead branch'
RETURN port, tree, flag

===================== compute trees =====================
MATCH (r:Router)-[:HAS_PORT]->(p:Port)-[:LINKS_TO]-()
WITH DISTINCT r,p
WITH collect(r.name+','+p.name) as ports
CALL trees.compute(ports, false) YIELD time
RETURN time

===================== get trees ==========================
MATCH (s:State)<-[:ORIG_STATE]-()
MATCH path = (s)-[:FWD_NEXT*]->(e:State) WHERE NOT (e)-[:FWD_NEXT]->()
UNWIND nodes(path) AS n
MATCH (n)<-[]-(p:Port)<-[:HAS_PORT]-(r:Router) 
WITH path, collect({state: n, router:r, port:p}) as ports, e
RETURN REDUCE(s = '', pr IN ports | s + ' ' + pr.router.name + ',' + pr.port.name) AS paths, e.flag

============== test active ports waypoint ================
MATCH (r:Router)-[:HAS_PORT]->(p:Port)-[:LINKS_TO]-()
WITH DISTINCT r, p
MATCH path = ()-[:ORIG_STATE]->(os:State)-[:FWD_NEXT*]->(:State)<-[:FWD_STATE]-(:Port {name: p.name}) WHERE length(path) > 2
RETURN r.name+','+p.name AS portname, count(path)

============== find blackholes ===========================
MATCH (r:Router)-[:HAS_PORT|HAS_VLAN]->(i)-[:FWD]->(f:Fwd)-[:HAS_EC]->(ec:EC)
WITH r, COLLECT(ec) AS connectedECs
MATCH (allEC:EC) WHERE NOT allEC IN connectedECs
RETURN r, COLLECT(DISTINCT allEC.v) AS MissingECs


==============================================================
MATCH (r:Router)-[:HAS_PORT]->(p:Port)-[:LINKS_TO]-()
WITH DISTINCT r, p
CREATE (p)-[:ORIG_STATE {tmp:true}]->(s:FwdState {originPort: id(p), ecs: [], complement:true, tmp: true, visited: [id(p)]})
WITH s, p
CALL custom.traverse(id(s),id(p)) YIELD ignored
RETURN null as ignored
----------------
MATCH (r:Router {name: 'coza_rtr'})-[:HAS_PORT]->(p:Port {name: 'te2/1'})
WITH DISTINCT p
CREATE (p)-[:ORIG_STATE {tmp:true}]->(s:FwdState {originPort: id(p), ecs: [], complement:true, tmp: true, visited: [id(p)]})
WITH s,p
CALL custom.traverse(id(s),id(p)) YIELD ignored
RETURN null as ignored
----------------
CALL apoc.custom.asProcedure("traverse", 
"WITH $fwdstate_id AS fwdstate_id, $port_id AS port_id 
MATCH (r:Router)-[:HAS_PORT]->(p:Port)-[:ORIG_STATE|TRANSFER_STATE]->(s:FwdState) WHERE id(p)=port_id AND id(s)=fwdstate_id
CALL {
    WITH p, s
    OPTIONAL MATCH (p)-[:INACL]->(inacl:InAcl)-[:HAS_EC]->(ec:EC)
    WITH CASE inacl WHEN null THEN ap.intersect(s.ecs,s.complement,[],true) ELSE ap.intersect(s.ecs,s.complement,collect(ec.v),inacl.complement) END AS xfwdaps
    WITH tail(xfwdaps) as fwdaps, CASE head(xfwdaps) WHEN 0 THEN false WHEN 1 THEN true END AS fwdapsComp
    WITH fwdaps, fwdapsComp WHERE NOT (size(fwdaps) = 0 AND fwdapsComp = false)
    RETURN fwdaps, fwdapsComp
}
WITH r, p, s, fwdaps, fwdapsComp
CALL {
    WITH r, p, fwdaps, fwdapsComp
    MATCH (r)-[:HAS_PORT]->(pi:Port)-[:FWD]->(f:Fwd)-[:HAS_EC]->(ec:EC) WHERE pi.name <> p.name
    WITH DISTINCT pi, ap.intersect(fwdaps,fwdapsComp,collect(ec.v),f.complement) as fwdaps2
    WITH pi, fwdaps2 WHERE NOT (size(fwdaps2) = 1 AND head(fwdaps2) = 0)
    RETURN pi AS outport, fwdaps2
    UNION
    WITH r, p, fwdaps, fwdapsComp
    MATCH (r)-[:HAS_VLAN]->(vi:Vlan)-[:FWD]->(f:Fwd)-[:HAS_EC]->(ec:EC) WHERE vi.name <> p.name
    WITH DISTINCT p, vi, ap.intersect(fwdaps,fwdapsComp,collect(ec.v),f.complement) as fwdaps2
    WITH p, vi, fwdaps2 WHERE NOT (size(fwdaps2) = 1 AND head(fwdaps2) = 0)
    MATCH (vi)-[:IS_VLANPORT]-(pi:Port) WHERE pi.name <> p.name
    RETURN pi as outport, fwdaps2
}
WITH s, outport, ap.unions(COLLECT(fwdaps2)) AS fwdaps2
WITH s, outport, tail(fwdaps2) as fwdaps3, CASE head(fwdaps2) WHEN 0 THEN false WHEN 1 THEN true END AS fwdaps3Comp 
WITH s, outport, fwdaps3, fwdaps3Comp WHERE NOT (size(fwdaps3) = 0 AND fwdaps3Comp = false)
OPTIONAL MATCH (outport)-[:OUTACL]->(outacl:OutAcl)-[:HAS_EC]->(ec:EC)
WITH DISTINCT s, outport, fwdaps3, fwdaps3Comp, CASE outacl WHEN null THEN ap.intersect(fwdaps3,fwdaps3Comp,[],true) ELSE ap.intersect(fwdaps3,fwdaps3Comp,collect(ec.v),outacl.complement) END AS xfwdaps4
WITH s, outport, tail(xfwdaps4) as fwdaps4, CASE head(xfwdaps4) WHEN 0 THEN false WHEN 1 THEN true END AS fwdaps4Comp 
WITH s, outport, fwdaps4, fwdaps4Comp WHERE NOT (size(fwdaps4) = 0 AND fwdaps4Comp = false)
WITH s, outport, fwdaps4, fwdaps4Comp
CREATE (s)-[:FWD_NEXT {tmp:true}]->(nxt:FwdState {ecs: fwdaps4, complement: fwdaps4Comp, originPort: s.originPort, visited: s.visited+id(outport), tmp:true})<-[:FWD_STATE {tmp:true}]-(outport)
REMOVE s.flag
SET nxt.flag = CASE (size(nxt.visited) = size(apoc.coll.toSet(nxt.visited))) WHEN false THEN CASE s.originPort IN tail(nxt.visited) WHEN true THEN 'loop' WHEN false THEN 'branch loop' END WHEN true THEN 'dead' END
WITH outport, nxt WHERE nxt.flag = 'dead'
MATCH (outport)-[:LINKS_TO]-(np:Port)
REMOVE nxt.flag
WITH DISTINCT np, nxt 
CREATE (nxt)-[:FWD_NEXT {tmp:true}]->(tf:FwdState {ecs: nxt.ecs, complement: nxt.complement, originPort: nxt.originPort, visited: nxt.visited+id(np), flag: 'dead', tmp:true})<-[:TRANSFER_STATE {tmp:true}]-(np)
WITH np, tf
CALL custom.traverse(id(tf),id(np)) YIELD ignored
RETURN null AS ignored", 'write', [['ignored', 'STRING']], [['fwdstate_id', 'INTEGER'],['port_id', 'INTEGER']], '')
==========================================================================

CALL gds.graph.project(
  'fwd-graph',
  ['MyLabel'],
  { nodeProperties: ['prop1', 'prop2] },
  ['MY_TYPE'],
  { relationshipProperties: ['prop1', 'prop2] })
  YIELD graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipProjection, relationshipCount AS rels


CALL gds.graph.project(
  'fwd',
  {
     <projected-label>: {
        label: State,
        properties: [<neo4j-property-key>, <neo4j-property-key>, ...]
     }, 
     <projected-label>: {
        label: Port,
        properties: [<neo4j-property-key>, <neo4j-property-key>, ...]
     }
  },
  ['FWD_STATE']
)
YIELD graphName AS graph, nodeProjection, nodeCount AS nodes, relationshipProjection, relationshipCount AS rels

-------------------------
MATCH (source) WHERE source:Person OR source:Book
OPTIONAL MATCH (source)-[r:KNOWS|READ]->(target)
WHERE target:Person OR target:Book
WITH gds.graph.project(
  'personsAndBooks',
  source,
  target,
  {
    sourceNodeLabels: labels(source),
    targetNodeLabels: labels(target),
    relationshipType: type(r)
  }
) AS g
RETURN g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels

-------------------
CALL gds.graph.drop('fwd-graph') YIELD graphName;

